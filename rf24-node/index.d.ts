/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * Optional configuration parameters to fine tune instantiating the RF24 object.
 * Pass this object as third parameter to RF24 constructor.
 */
export interface HardwareConfig {
  /**
   * The GPIO chip number: `/dev/gpiochipN` where `N` is this value.
   *
   * Defaults to `0`, but needs to be `4` on RPi5 (or newer).
   * This may also need to be specified for nVidia's hardware offerings.
   */
  devGpioChip?: number
  /**
   * The SPI bus number: `/dev/spidevX.Y` where `X` is this value
   * and `Y` is the `csPin` required parameter to RF24 constructor
   *
   * Defaults to 0, but can be as high as 3 depending on the number of
   * SPI buses available/exposed on the board.
   */
  devSpiBus?: number
  /**
   * The SPI speed in Hz used to communicate with the nRF24L01 over SPI.
   *
   * Defaults to 10 MHz (`10000000`) which is the radio's maximum
   * supported speed. Lower this to 6 or 4 MHz when using long wires or
   * if builtin pull-up resistors are weak.
   */
  spiSpeed?: number
}
/**
 * The return type for `RF24.getStatusFlags()` and optional parameters for
 * `RF24.setStatusFlags()` and `RF24.clearStatusFlags()`
 */
export interface StatusFlags {
  /** Is RX Data Ready to read? */
  rxDr: boolean
  /** Is TX Data Sent? */
  txDs: boolean
  /** Has TX Data Failed? */
  txDf: boolean
}
/** An optional configuration for `RF24.write()` */
export interface WriteConfig {
  /**
   * Set to true if you want to disable auto-ACK feature for the individual
   * payload (required `buf` parameter to `RF24.write()`).
   *
   * Defaults to false. Be sure to invoke `RF24.allowAskNoAck(true)` at least once beforehand,
   * otherwise this option will have no affect at all.
   */
  askNoAck?: boolean
  /**
   * Set to true to assert the radio's CE pin (and begin active TX mode) after the payload is
   * uploaded to the TX FIFO.
   *
   * Only set this to false if filling the TX FIFO (maximum 3 level stack) before entering
   * active TX mode. Setting this option to false does not deactivate the radio's CE pin.
   */
  startTx?: boolean
}
/** The return type for `RF24.availablePipe()` */
export interface AvailablePipe {
  /** Is RX data available in the RX FIFO? */
  available: boolean
  /**
   * The pipe number that received the next available payload in the RX FIFO.
   *
   * This shall be considered an invalid value if `available` is false.
   */
  pipe: number
}
/**
 * Power Amplifier level. The units dBm (decibel-milliwatts or dB<sub>mW</sub>)
 * represents a logarithmic signal loss.
 */
export const enum PaLevel {
  /**
   * | nRF24L01 | Si24R1 with<br>LNA Enabled | Si24R1 with<br>LNA Disabled |
   * | :-------:|:--------------------------:|:---------------------------:|
   * | -18 dBm | -6 dBm | -12 dBm |
   */
  MIN = 0,
  /**
   * | nRF24L01 | Si24R1 with<br>LNA Enabled | Si24R1 with<br>LNA Disabled |
   * | :-------:|:--------------------------:|:---------------------------:|
   * | -12 dBm | 0 dBm | -4 dBm |
   */
  LOW = 1,
  /**
   * | nRF24L01 | Si24R1 with<br>LNA Enabled | Si24R1 with<br>LNA Disabled |
   * | :-------:|:--------------------------:|:---------------------------:|
   * | -6 dBm | 3 dBm | 1 dBm |
   */
  HIGH = 2,
  /**
   * | nRF24L01 | Si24R1 with<br>LNA Enabled | Si24R1 with<br>LNA Disabled |
   * | :-------:|:--------------------------:|:---------------------------:|
   * | 0 dBm | 7 dBm | 4 dBm |
   */
  MAX = 3
}
/** How fast data moves through the air. Units are in bits per second (bps). */
export const enum DataRate {
  /** represents 1 Mbps */
  Mbps1 = 0,
  /** represents 2 Mbps */
  Mbps2 = 1,
  /** represents 250 Kbps */
  Kbps250 = 2
}
/**
 * The length of a CRC checksum that is used (if any).
 *
 * Cyclical Redundancy Checking (CRC) is commonly used to ensure data integrity.
 */
export const enum CrcLength {
  /** represents no CRC checksum is used */
  DISABLED = 0,
  /** represents CRC 8 bit checksum is used */
  BIT8 = 1,
  /** represents CRC 16 bit checksum is used */
  BIT16 = 2
}
/** The possible states of a FIFO. */
export const enum FifoState {
  /** Represent the state of a FIFO when it is full. */
  Full = 0,
  /** Represent the state of a FIFO when it is empty. */
  Empty = 1,
  /** Represent the state of a FIFO when it is not full but not empty either. */
  Occupied = 2
}
export type NodeRF24 = RF24
export declare class RF24 {
  constructor(cePin: number, csPin: number, hardwareConfig?: HardwareConfig | undefined | null)
  begin(): void
  startListening(): void
  stopListening(): void
  send(buf: Buffer, askNoAck?: boolean | undefined | null): boolean
  write(buf: Buffer, writeConfig?: WriteConfig | undefined | null): boolean
  read(len: number): Buffer
  resend(): boolean
  rewrite(): void
  getLastArc(): number
  isPlusVariant(): boolean
  testRpd(): boolean
  startCarrierWave(level: PaLevel, channel: number): void
  stopCarrierWave(): void
  setLna(enable: boolean): void
  allowAckPayloads(enable: boolean): void
  setAutoAck(enable: boolean): void
  setAutoAckPipe(enable: boolean, pipe: number): void
  allowAskNoAck(enable: boolean): void
  writeAckPayload(pipe: number, buf: Buffer): boolean
  setAutoRetries(delay: number, count: number): void
  setChannel(channel: number): void
  getChannel(): number
  getCrcLength(): CrcLength
  setCrcLength(crcLength: CrcLength): void
  getDataRate(): DataRate
  setDataRate(dataRate: DataRate): void
  available(): boolean
  availablePipe(): AvailablePipe
  /** Use this to discard all 3 layers in the radio's RX FIFO. */
  flushRx(): void
  /** Use this to discard all 3 layers in the radio's TX FIFO. */
  flushTx(): void
  getFifoState(aboutTx: boolean): FifoState
  getPaLevel(): PaLevel
  setPaLevel(paLevel: PaLevel): void
  setPayloadLength(length: number): void
  getPayloadLength(): number
  setDynamicPayloads(enable: boolean): void
  getDynamicPayloadLength(): number
  openRxPipe(pipe: number, address: Buffer): void
  openTxPipe(address: Buffer): void
  /** If the given `pipe` number is  not in range [0, 5], then this function does nothing. */
  closeRxPipe(pipe: number): void
  setAddressLength(length: number): void
  getAddressLength(): number
  powerDown(): void
  powerUp(delay?: number | undefined | null): void
  setStatusFlags(statusFlags?: StatusFlags | undefined | null): void
  clearStatusFlags(statusFlags?: StatusFlags | undefined | null): void
  update(): void
  getStatusFlags(): StatusFlags
}
